<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Love Editor</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: sans-serif;
      background: #0e0e0e;
      color: #fff;
      overflow: hidden;
    }

    /* ─── Sidebar ─── */
    #sidebar {
      width: 250px;
      border-right: 1px solid #2a2a2a;
      padding: 10px;
      overflow-y: auto;
      background: #151515;
      color: #fff;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #sidebar input[type="file"] {
      font-size: 12px;
      color: #aaa;
    }

    button {
      width: 100%;
      margin-top: 6px;
      padding: 6px 10px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #1e1e1e;
      color: #ccc;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.15s, border-color 0.15s;
    }
    button:hover {
      background: #2a2a2a;
      border-color: #555;
    }
    button.active {
      border-color: #4fc3f7;
      background: #1a2a3a;
      color: #4fc3f7;
    }

    .tree-item {
      cursor: pointer;
      padding: 4px 6px;
      user-select: none;
      border-radius: 3px;
      font-size: 13px;
      color: #ccc;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tree-item:hover { background: #0050aa; color: #fff; }
    .tree-item.selected { background: #0050aa; color: #fff; }

    /* ─── Main area (editor / terminal share this) ─── */
    #editor {
      flex: 1;
      min-width: 0;
    }

    /* ─── Terminal Panel ─── */
    #terminal-panel {
      display: none;           /* toggled by JS */
      flex-direction: column;
      flex: 1;
      min-width: 0;
      background: #0d1117;
      font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 13px;
      color: #c9d1d9;
    }

    /* top bar */
    #terminal-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: #161b22;
      border-bottom: 1px solid #30363d;
      flex-shrink: 0;
    }
    #terminal-bar .dot {
      width: 12px; height: 12px;
      border-radius: 50%;
    }
    .dot.red   { background: #ff5f57; }
    .dot.yel   { background: #ffbd2e; }
    .dot.grn   { background: #28c840; }
    #terminal-bar .bar-title {
      margin-left: 6px;
      font-size: 12px;
      color: #8b949e;
      flex: 1;
    }
    #terminal-bar button {
      width: auto;
      margin-top: 0;
      padding: 3px 10px;
      font-size: 11px;
    }

    /* output scroll area */
    #terminal-output {
      flex: 1;
      overflow-y: auto;
      padding: 10px 14px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .term-line {
      display: flex;
      gap: 8px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .term-line .prefix {
      flex-shrink: 0;
      width: 60px;
      text-align: right;
      font-size: 11px;
      opacity: 0.5;
    }
    .term-line .msg { flex: 1; }

    /* colour variants */
    .term-line.log   .msg { color: #c9d1d9; }
    .term-line.warn  .msg { color: #e3b341; }
    .term-line.error .msg { color: #f85149; }
    .term-line.info  .msg { color: #58a6ff; }
    .term-line.input-echo .prefix { color: #7ee787; }
    .term-line.input-echo .msg    { color: #7ee787; }

    /* input row */
    #terminal-input-row {
      display: flex;
      align-items: center;
      border-top: 1px solid #30363d;
      background: #161b22;
      padding: 6px 14px;
      flex-shrink: 0;
      gap: 6px;
    }
    #terminal-input-row .prompt {
      color: #7ee787;
      font-weight: bold;
      flex-shrink: 0;
    }
    #terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: #c9d1d9;
      font-family: inherit;
      font-size: 13px;
      caret-color: #58a6ff;
    }
    #terminal-input::selection { background: #264f78; }

    /* history nav hint */
    #terminal-input-row .hint {
      font-size: 10px;
      color: #484f58;
      flex-shrink: 0;
    }

    /* scrollbar (webkit) */
    #terminal-output::-webkit-scrollbar { width: 6px; }
    #terminal-output::-webkit-scrollbar-track { background: transparent; }
    #terminal-output::-webkit-scrollbar-thumb { background: #30363d; border-radius: 3px; }
  </style>
</head>

<body>
  <!-- ─── Sidebar ─── -->
  <div id="sidebar">
    <input type="file" id="zipInput" accept=".zip" />
    <button id="saveZip">Save ZIP</button>
    <button id="loadLove">Load Love</button>
    <button id="loadTerminal">Load Terminal</button>
    <hr style="border-color:#2a2a2a; margin:4px 0;" />
    <div id="fileTreeContainer">
      <div id="fileTree"></div>
    </div>
    <button id="addFile">Add File</button>
  </div>

  <!-- ─── Editor (Monaco lives here) ─── -->
  <div id="editor"></div>

  <!-- ─── Terminal (hidden until toggled) ─── -->
  <div id="terminal-panel">
    <div id="terminal-bar">
      <span class="dot red"></span>
      <span class="dot yel"></span>
      <span class="dot grn"></span>
      <span class="bar-title">Terminal — JavaScript</span>
      <button id="termClear">Clear</button>
      <button id="termClose">✕</button>
    </div>
    <div id="terminal-output"></div>
    <div id="terminal-input-row">
      <span class="prompt">&gt;</span>
      <input type="text" id="terminal-input" autocomplete="off" spellcheck="false" placeholder="Enter JS or: run &lt;filename&gt;" />
      <span class="hint">↑↓ history</span>
    </div>
  </div>

  <!-- Fflate -->
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>

  <!-- Monaco Loader -->
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>

  <!-- Terminal logic (self-contained, no dependency on main.js internals) -->
  <script>
  (function () {
    // ─── DOM refs ───
    const panel      = document.getElementById('terminal-panel');
    const output     = document.getElementById('terminal-output');
    const input      = document.getElementById('terminal-input');
    const btnLoad    = document.getElementById('loadTerminal');
    const btnClose   = document.getElementById('termClose');
    const btnClear   = document.getElementById('termClear');
    const editorDiv  = document.getElementById('editor');

    // ─── State ───
    let history = [];          // command history
    let histIdx = -1;          // pointer into history
    let isOpen  = false;

    // ─── Toggle open / close ───
    btnLoad.addEventListener('click', () => {
      if (isOpen) { closeTerminal(); } else { openTerminal(); }
    });
    btnClose.addEventListener('click', closeTerminal);

    function openTerminal () {
      isOpen = true;
      editorDiv.style.display  = 'none';
      panel.style.display      = 'flex';
      btnLoad.classList.add('active');
      btnLoad.textContent      = 'Close Terminal';
      input.focus();
      appendLine('info', 'Terminal ready.  Type JS or use: run <filename.js>');
    }
    function closeTerminal () {
      isOpen = false;
      editorDiv.style.display  = '';
      panel.style.display      = 'none';
      btnLoad.classList.remove('active');
      btnLoad.textContent      = 'Load Terminal';
    }

    // ─── Clear ───
    btnClear.addEventListener('click', () => { output.innerHTML = ''; });

    // ─── Input handling ───
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter')     { e.preventDefault(); submitCommand(); }
      if (e.key === 'ArrowUp')   { e.preventDefault(); navHistory(-1); }
      if (e.key === 'ArrowDown') { e.preventDefault(); navHistory(1);  }
    });

    function navHistory (dir) {
      histIdx = Math.max(-1, Math.min(history.length - 1, histIdx + dir));
      input.value = histIdx >= 0 ? history[histIdx] : '';
    }

    // ─── Submit ───
    function submitCommand () {
      const raw = input.value.trim();
      input.value = '';
      if (!raw) return;

      // push to history
      history.unshift(raw);
      if (history.length > 200) history.pop();
      histIdx = -1;

      // echo the command
      appendLine('input-echo', raw);

      // ── special: run <file> ──
      const runMatch = raw.match(/^run\s+(.+)$/i);
      if (runMatch) {
        const fname = runMatch[1].trim();
        // Try to pull source from the virtual FS that main.js keeps.
        // main.js is expected to expose `window._loveFiles` as { path: content }
        const files = window._loveFiles || {};
        const source = files[fname] ?? files['/' + fname] ?? null;
        if (source == null) {
          appendLine('error', `File not found: "${fname}"\nLoaded files: ${Object.keys(files).join(', ') || '(none)'}`);
        } else {
          execCode(source, fname);
        }
        return;
      }

      // ── default: eval the input directly ──
      execCode(raw, '<input>');
    }

    // ─── Execute code with intercepted console ───
    function execCode (code, label) {
      const orig = {
        log:   console.log,
        warn:  console.warn,
        error: console.error,
        info:  console.info,
        debug: console.debug
      };

      console.log   = (...a) => { orig.log(...a);   appendLine('log',   fmt(a)); };
      console.warn  = (...a) => { orig.warn(...a);  appendLine('warn',  fmt(a)); };
      console.error = (...a) => { orig.error(...a); appendLine('error', fmt(a)); };
      console.info  = (...a) => { orig.info(...a);  appendLine('info',  fmt(a)); };
      console.debug = (...a) => { orig.log(...a);   appendLine('log',   fmt(a)); };

      try {
        // Wrap in an async IIFE so top-level await works in typed commands
        const fn = new Function('__label__',
          `"use strict";\n(async () => {\n${code}\n})();`
        );
        const result = fn(label);
        // If it's a promise, catch async errors too
        if (result && typeof result.catch === 'function') {
          result.catch((err) => {
            appendLine('error', `[${label}] Async error: ${err}`);
            restore();
          }).then(() => restore());
        } else {
          restore();
        }
      } catch (err) {
        appendLine('error', `[${label}] ${err}`);
        restore();
      }

      function restore () {
        console.log   = orig.log;
        console.warn  = orig.warn;
        console.error = orig.error;
        console.info  = orig.info;
        console.debug = orig.debug;
      }
    }

    // ─── Helpers ───
    function fmt (args) {
      return args.map(a => (typeof a === 'object' && a !== null)
        ? JSON.stringify(a, null, 2)
        : String(a)
      ).join(' ');
    }

    function appendLine (type, text) {
      const line = document.createElement('div');
      line.className = 'term-line ' + type;

      const prefix = document.createElement('span');
      prefix.className = 'prefix';
      prefix.textContent = type === 'input-echo' ? '>' : type.toUpperCase();

      const msg = document.createElement('span');
      msg.className = 'msg';
      msg.textContent = text;

      line.appendChild(prefix);
      line.appendChild(msg);
      output.appendChild(line);
      output.scrollTop = output.scrollHeight;   // auto-scroll
    }

    // ─── Expose appendLine globally so main.js can also pipe into it ───
    window._termAppend = appendLine;
  })();
  </script>

  <script src="main.js"></script>
</body>

</html>